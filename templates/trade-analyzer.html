<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fantasy Basketball Trade Analyzer</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
  --primary-color: #3498db;
  --primary-dark: #2980b9;
  --secondary-color: #f1c40f;
  --secondary-light: #f4d03f;
  --accent-color: #e74c3c;
  --accent-light: #e57373;
  --success-color: #2ecc71;
  --success-light: #a7e9c3;
  --dark-bg: #1d2a3a;
  --darker-bg: #172331;
  --card-bg: rgba(255, 255, 255, 0.08);
  --card-hover: rgba(255, 255, 255, 0.12);
  --player-bg: #2c3e50;
  --player-hover: #c0392b;
  --text-light: #ffffff;
  --text-dim: #ecf0f1;
  --text-muted: #bdc3c7;
  --shadow-sm: 0 2px 10px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 15px rgba(0, 0, 0, 0.15);
  --shadow-lg: 0 8px 30px rgba(0, 0, 0, 0.2);
  --shadow-inner: inset 0 2px 10px rgba(0, 0, 0, 0.1);
  --border-radius-sm: 8px;
  --border-radius-md: 12px;
  --border-radius-lg: 25px;
  --transition-fast: 0.2s ease;
  --transition-medium: 0.3s ease;
  --glow-primary: 0 0 15px rgba(52, 152, 219, 0.5);
  --glow-secondary: 0 0 15px rgba(241, 196, 15, 0.5);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(135deg, var(--dark-bg), #333);
  color: var(--text-light);
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  width: 100vw;
  overflow-x: hidden;
  line-height: 1.6;
  background-attachment: fixed;
  position: relative;
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.1;
  z-index: -1;
  pointer-events: none;
}

.container {
  background-color: var(--card-bg);
  border-radius: var(--border-radius-lg);
  box-shadow: var(--shadow-lg);
  width: 92%;
  max-width: 1200px;
  padding: 40px;
  backdrop-filter: blur(15px);
  overflow: hidden;
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  margin: 40px 0;
  position: relative;
}

.container::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, transparent, var(--primary-color), var(--secondary-color), var(--accent-color), transparent);
  opacity: 0.7;
}

.header {
  margin-bottom: 35px;
  position: relative;
}

.header::after {
  content: '';
  position: absolute;
  bottom: -15px;
  left: 50%;
  transform: translateX(-50%);
  width: 150px;
  height: 3px;
  background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
}

h2 {
  font-size: 2.8rem;
  color: var(--secondary-color);
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 3px;
  font-weight: 700;
  text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.3);
}

.sub-header {
  color: var(--text-muted);
  font-size: 1.1rem;
  font-weight: 300;
  margin-bottom: 10px;
}

.teams-container {
  display: flex;
  justify-content: space-between;
  gap: 30px;
  flex-wrap: wrap;
  width: 100%;
  margin-bottom: 30px;
  position: relative;
  z-index: 5000;
}

.team {
  background-color: var(--card-bg);
  padding: 15px;
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
  width: 48%;
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 1px solid rgba(255, 255, 255, 0.05);
  transition: all var(--transition-medium);
  position: relative;
  overflow: visible;
  z-index: 5000;
}

.team::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.1), transparent);
  opacity: 0.5;
  z-index: -1;
}

.team:hover {
  transform: translateY(-5px);
  box-shadow: var(--shadow-lg);
  background-color: var(--card-hover);
}

.team h3 {
  font-size: 1.3rem;
  color: var(--primary-color);
  margin-bottom: 10px;
  font-weight: 600;
  text-transform: capitalize;
  text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.2);
  position: relative;
  z-index: 1;
  display: inline-block;
}

.team h3::after {
  content: '';
  position: absolute;
  left: 0;
  bottom: -3px;
  width: 100%;
  height: 2px;
  background: var(--primary-color);
  transform: scaleX(0);
  transform-origin: right;
  transition: transform var(--transition-medium);
}

.team:hover h3::after {
  transform: scaleX(1);
  transform-origin: left;
}

.team h4 {
  font-size: 1.3rem;
  color: var(--accent-color);
  margin-bottom: 10px;
  font-weight: 600;
  text-transform: capitalize;
  text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.2);
  position: relative;
  z-index: 1;
  display: inline-block;
}

.team h4::after {
  content: '';
  position: absolute;
  left: 0;
  bottom: -3px;
  width: 100%;
  height: 2px;
  background: var(--accent-color);
  transform: scaleX(0);
  transform-origin: right;
  transition: transform var(--transition-medium);
}

.team:hover h4::after {
  transform: scaleX(1);
  transform-origin: left;
}

.search-container {
  position: relative;
  width: 80%;
  margin-bottom: 10px;
  z-index: 5000;
}

.team input {
  width: 100%;
  padding: 10px 15px;
  margin: 4px 0;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: var(--border-radius-sm);
  font-size: 1rem;
  background-color: var(--darker-bg);
  color: var(--text-light);
  transition: all var(--transition-medium);
  box-shadow: var(--shadow-inner);
}

.team input:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: var(--glow-primary);
}

.team input::placeholder {
  color: var(--text-muted);
  transition: all var(--transition-medium);
}

.team input:focus::placeholder {
  opacity: 0.7;
  transform: translateX(5px);
}

.autocomplete-container {
  position: absolute;
  z-index: 1000;
  background-color: var(--darker-bg);
  width: 100%;
  max-height: 250px;
  overflow-y: auto;
  border-radius: var(--border-radius-sm);
  box-shadow: var(--shadow-md);
  border: 1px solid rgba(255, 255, 255, 0.1);
  scrollbar-width: thin;
  scrollbar-color: var(--primary-color) var(--darker-bg);
  top: 100%;  /* Position it right below the input */
  left: 0;    /* Align with the left edge */
}

.autocomplete-container::-webkit-scrollbar {
  width: 6px;
}

.autocomplete-container::-webkit-scrollbar-track {
  background: var(--darker-bg);
}

.autocomplete-container::-webkit-scrollbar-thumb {
  background-color: var(--primary-color);
  border-radius: 20px;
}

.autocomplete-container div {
  padding: 12px 15px;
  cursor: pointer;
  transition: all var(--transition-fast);
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  z-index: 5000;
}

.autocomplete-container div:last-child {
  border-bottom: none;
}

.autocomplete-container div:hover {
  background-color: var(--primary-color);
  color: white;
  font-weight: 500;
  padding-left: 20px;
}

.watchlist {
  width: 100%;
  margin-top: 5px;
}

.players-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 5px;
}

.player-item {
  background-color: var(--player-bg);
  padding: 8px 10px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  text-align: center;
  font-size: 0.9rem;
  color: var(--text-light);
  transition: all var(--transition-medium);
  box-shadow: var(--shadow-sm);
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.player-item::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  transition: left 0.5s ease;
}

.player-item:hover::before {
  left: 100%;
}

.player-item:hover {
  background-color: var(--player-hover);
  transform: translateY(-3px);
  box-shadow: var(--shadow-md);
  color: var(--text-dim);
}

.player-item::after {
  content: "Ã—";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 1.2rem;
  opacity: 0;
  transition: opacity var(--transition-fast);
}

.player-item:hover::after {
  opacity: 1;
}

.analyze-btn {
  background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
  color: white;
  border: none;
  padding: 15px 35px;
  font-size: 1.3rem;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  transition: all var(--transition-medium);
  margin-top: 30px;
  font-weight: 600;
  letter-spacing: 1px;
  box-shadow: var(--shadow-md), 0 0 0 rgba(52, 152, 219, 0);
  position: relative;
  overflow: hidden;
  transform: translateZ(0);
  z-index: 100;
}

.analyze-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));
  transform: translateY(-100%);
  transition: transform var(--transition-medium);
  z-index: 1;
}

.analyze-btn::after {
  content: '';
  position: absolute;
  left: 50%;
  top: 50%;
  width: 120%;
  height: 0;
  padding-bottom: 120%;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  transform: translate(-50%, -50%) scale(0);
  opacity: 0;
  z-index: 0;
  transition: transform 0.5s, opacity 0.4s;
}

.analyze-btn:hover {
  transform: translateY(-5px) translateZ(0);
  box-shadow: var(--shadow-lg), 0 0 10px rgba(52, 152, 219, 0.5);
  letter-spacing: 2px;
}

.analyze-btn:hover::before {
  transform: translateY(0);
}

.analyze-btn:active::after {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
  transition: transform 0s, opacity 0.4s;
}

.analyze-btn:disabled {
  background: #95a5a6;
  cursor: not-allowed;
  transform: none;
  box-shadow: var(--shadow-sm);
}

.analyze-btn span {
  position: relative;
  z-index: 2;
}

#trade-result {
  margin-top: 30px;
  font-size: 1.2rem;
  font-weight: 500;
  padding: 30px;
  background-color: rgba(44, 62, 80, 0.7);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
  color: var(--secondary-color);
  border: 1px solid rgba(255, 255, 255, 0.05);
  transition: all var(--transition-medium);
  /* Hide it initially */
  max-height: 0;
  padding: 0;
  margin: 0;
  opacity: 0;
  overflow: hidden;
  pointer-events: none;
  position: relative;
}

#trade-result::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at bottom right, rgba(255, 255, 255, 0.1), transparent);
  opacity: 0.2;
  z-index: -1;
}

#trade-result.active {
  max-height: 1000px;
  margin-top: 30px;
  padding: 30px;
  opacity: 1;
  pointer-events: auto;
  border-width: 1px;
  animation: fadeIn 0.5s ease forwards;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.result-title {
  font-size: 1.6rem;
  margin-bottom: 25px;
  color: var(--secondary-color);
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
  position: relative;
  display: inline-block;
}

.result-title::after {
  content: '';
  position: absolute;
  bottom: -10px;
  left: 50%;
  transform: translateX(-50%);
  width: 50%;
  height: 2px;
  background: var(--secondary-color);
  opacity: 0.7;
}

.teams-comparison {
  display: flex;
  justify-content: space-between;
  text-align: left;
  gap: 30px;
}

.team-column {
  width: 48%;
  padding: 15px;
  border-radius: var(--border-radius-sm);
  background-color: rgba(255, 255, 255, 0.05);
  box-shadow: var(--shadow-inner);
}

.team-column h3 {
  margin-bottom: 15px;
  font-size: 1.4rem;
  text-align: center;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  margin-top: 5px;
}

.team-column .player-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  transition: all var(--transition-fast);
  border-radius: var(--border-radius-sm);
}

.team-column .player-row:hover {
  background-color: rgba(255, 255, 255, 0.05);
  transform: translateX(5px);
}

.team-column .player-name {
  color: var(--text-light);
  display: flex;
  align-items: center;
}

.team-column .player-value {
  color: var(--secondary-color);
  font-weight: 600;
  background-color: rgba(0, 0, 0, 0.2);
  padding: 2px 8px;
  border-radius: 20px;
  min-width: 70px;
  text-align: center;
}

.team-total {
  margin-top: 15px;
  padding: 15px 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
  font-weight: 700;
  display: flex;
  justify-content: space-between;
  background-color: rgba(0, 0, 0, 0.15);
  border-radius: var(--border-radius-sm);
}

.team-total span:last-child {
  background-color: rgba(241, 196, 15, 0.2);
  padding: 2px 10px;
  border-radius: 20px;
}

.loading-spinner {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: white;
  animation: spin 1s ease-in-out infinite;
  margin-left: 10px;
  vertical-align: middle;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.cache-indicator {
  font-size: 0.7rem;
  padding: 2px 6px;
  background-color: rgba(46, 204, 113, 0.2);
  border-radius: 4px;
  color: var(--success-light);
  margin-left: 8px;
  vertical-align: middle;
}

.footer {
  margin-top: 40px;
  font-size: 0.9rem;
  color: var(--text-muted);
  padding-top: 15px;
  border-top: 1px solid rgba(255, 255, 255, 0.05);
}

.debug-panel {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.7);
  border-radius: var(--border-radius-sm);
  padding: 10px;
  font-size: 0.8rem;
  color: var(--text-muted);
  max-width: 250px;
  display: none;
  z-index: 1000;
  backdrop-filter: blur(5px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.win-indicator {
  color: var(--success-color);
  font-weight: 600;
}

.lose-indicator {
  color: var(--accent-color);
  font-weight: 600;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .container {
    padding: 20px;
    width: 95%;
  }

  .teams-container {
    flex-direction: column;
    gap: 20px;
  }

  .team {
    width: 100%;
  }

  .teams-comparison {
    flex-direction: column;
    gap: 20px;
  }

  .team-column {
    width: 100%;
  }

  h2 {
    font-size: 2rem;
  }

  .analyze-btn {
    padding: 12px 25px;
    font-size: 1.1rem;
  }
}

/* Improved Font Scaling and Sizing */

/* Main Title */
h2 {
  font-size: 2.3rem; /* Slightly smaller for better proportions */
  letter-spacing: 2px; /* Less extreme letter spacing */
  margin-bottom: 12px;
}

/* Subtitle */
.sub-header {
  font-size: 1rem;
  max-width: 600px;
  margin: 0 auto 15px;
}

/* Team Headers */
.team h3, .team h4 {
  font-size: 1.2rem;
  margin-bottom: 15px;
  font-weight: 600;
}

/* Search Input */
.team input {
  font-size: 0.95rem;
  padding: 8px 12px;
}

/* Autocomplete Items */
.autocomplete-container div {
  padding: 10px 15px;
  font-size: 0.9rem;
}

/* Player Items */
.player-item {
  font-size: 0.85rem;
  padding: 7px 10px;
}

/* Analyze Button */
.analyze-btn {
  font-size: 1.1rem;
  padding: 12px 30px;
  margin-top: 25px;
}

/* Container Sizing */
.container {
  padding: 35px;
  max-width: 1100px;
}

.teams-container {
  gap: 25px;
  margin-bottom: 25px;
}

.team {
  padding: 20px 15px;
}

/* Results Section */
.result-title {
  font-size: 1.4rem;
  margin-bottom: 20px;
}

.team-column {
  padding: 15px 12px;
}

.team-column h3 {
  font-size: 1.2rem;
  margin-bottom: 12px;
  padding-bottom: 8px;
}

.team-column .player-row {
  padding: 6px 10px;
  margin-bottom: 6px;
  font-size: 0.9rem;
}

.team-column .player-value {
  padding: 2px 8px;
  min-width: 65px;
  font-size: 0.85rem;
}

.team-total {
  margin-top: 12px;
  padding: 12px 10px;
  font-size: 0.95rem;
}

/* Footer */
.footer {
  margin-top: 30px;
  font-size: 0.8rem;
  padding-top: 12px;
}

/* Consistent spacing and alignment */
.search-container {
  margin-bottom: 12px;
}

/* Improved responsive adjustments */
@media (max-width: 768px) {
  h2 {
    font-size: 1.8rem;
  }
  
  .container {
    padding: 25px 20px;
  }
  
  .analyze-btn {
    padding: 10px 20px;
    font-size: 1rem;
  }
  
  .teams-container {
    gap: 15px;
  }
}

/* Overall color contrast improvements */
.team-column .player-value {
  color: var(--secondary-color);
  background-color: rgba(0, 0, 0, 0.25);
}

.cache-indicator {
  font-size: 0.65rem;
}
  </style>
</head>
<body>

  <div class="container">
    <div class="header">
      <h2>Fantasy Basketball Trade Analyzer</h2>
      <div class="sub-header">Compare player values and find the best trades for your team</div>
    </div>

    <div class="teams-container">
      <div class="team">
        <h3>Team 1 (What I'm Giving)</h3>
        <div class="search-container">
          <input type="text" id="player-search" placeholder="Search for a player...">
          <div id="autocomplete-container" class="autocomplete-container"></div>
        </div>
        <div id="watchlist" class="watchlist"></div>
      </div>

      <div class="team">
        <h4>Team 2 (What I'm Receiving)</h4>
        <div class="search-container">
          <input type="text" id="player-search-2" placeholder="Search for a player...">
          <div id="autocomplete-container-2" class="autocomplete-container"></div>
        </div>
        <div id="watchlist-2" class="watchlist"></div>
      </div>
    </div>

    <button class="analyze-btn" id="analyze-btn"><span>Analyze Trade</span></button>
    <div id="trade-result"></div>

    <div class="footer">
      Analyses based on BPV (Basketball Player Value) calculations using current season stats (80%) and last 5 games (20%) multiplied by Career GP%
    </div>
  </div>

  <div class="debug-panel" id="debug-panel">
    <div>Cache Stats:</div>
    <div id="cache-stats"></div>
    <div id="performance-stats"></div>
  </div>

  <script>
    const apiUrl = 'http://127.0.0.1:5000/api/player_comprehensive_data';
    let activePlayers = [];
    let team1Players = [];
    let team2Players = [];
    
    // Add player caching
    const playerStatsCache = {};
    const last5GamesCache = {};
    let debugMode = false;

    // Toggle debug panel with Ctrl+Shift+D
    document.addEventListener('keydown', function(event) {
      if (event.ctrlKey && event.shiftKey && event.key === 'D') {
        debugMode = !debugMode;
        document.getElementById('debug-panel').style.display = debugMode ? 'block' : 'none';
        updateDebugPanel();
      }
    });

    function updateDebugPanel() {
      if (!debugMode) return;
      
      const seasonCacheCount = Object.keys(playerStatsCache).length;
      const last5GamesCacheCount = Object.keys(last5GamesCache).length;
      
      document.getElementById('cache-stats').innerHTML = `
        Season data: ${seasonCacheCount} players<br>
        Last 5 games: ${last5GamesCacheCount} players
      `;
    }

    async function fetchActivePlayers() {
      try {
        const response = await fetch('http://127.0.0.1:5000/api/active_players');
        const players = await response.json();
        activePlayers = players;
      } catch (error) {
        console.error('Error fetching active players:', error);
      }
    }

    fetchActivePlayers();

// Add this after your existing variable declarations
const playersWith0BPV = [
  "Larry Nance Jr",
  "Jalen Johnson",
  "Kobe Bufkin",
  "Noah Clowney",
  "Cam Thomas",
  "Ayo Dosunmu",
  "Dante Exum",
  "Olivier-Maxence Prosper",
  "Kyrie Irving",
  "Daron Holmes II",
  "Jaden Ivey",
  "Isaiah Jackson",
  "Brandon Clarke",
  "Dru Smith",
  "CJ McCollum",
  "Trey Murphy III",
  "Herbert Jones",
  "Dejounte Murray",
  "Ariel Hukporti",
  "Nikola Topic",
  "Jalen Suggs",
  "Moritz Wagner",
  "Tyrese Maxey",
  "Joel Embiid",
  "Paul George",
  "Eric Gordon",
  "Jared McCain",
  "Bryce McGowens",
  "Robert Williams III",
  "Victor Wembanyama",
  "De'Aaron Fox",
  "Riley Minix",
  "Gradey Dick",
  "Ulrich Chomche",
  "Cody Williams",
  "Jordan Clarkson",
  "Elijah Harkless",
  "Taylor Hendricks",
  "Corey Kispert",
  "Bilal Coulibaly"
];

    // Update existing playerStatsCache and add comprehensiveDataCache
const comprehensiveDataCache = {};

// Replace the current fetchPlayerStats function with this optimized version
async function fetchPlayerStats(playerName) {
  if (!playerName) return { bpv: 0, cached: false };

  // Check if we already have this player in cache
  if (playerStatsCache[playerName]) {
    return { bpv: playerStatsCache[playerName], cached: true };
  }

  try {
    // Check if comprehensive data is already cached
    let data;
    if (comprehensiveDataCache[playerName]) {
      data = comprehensiveDataCache[playerName];
    } else {
      // Use the comprehensive data endpoint instead of multiple separate calls
      const response = await fetch(`http://127.0.0.1:5000/api/player_comprehensive_data?player_name=${encodeURIComponent(playerName)}`);
      data = await response.json();
      
      // Cache the comprehensive data
      comprehensiveDataCache[playerName] = data;
    }

    if (!data.player_stats) {
      console.error(`No stats found for ${playerName}`);
      return { bpv: 0, cached: false };
    }

    // Find the current season stats
    const latestSeason = data.player_stats.find((season) => season.SEASON_ID === "2024-25");
    if (!latestSeason) {
      console.warn(`No 2024-25 season data for ${playerName}`);
      return { bpv: 0, cached: false };
    }

    // Use last 5 games from comprehensive data
    const last5Games = data.last_5_games_player || [];
    
    // Calculate raw BPV with the last 5 games data included
    let bpv = await calculateBPV(latestSeason, playerName, last5Games, data);
    
    // Calculate Career GP%
    let careerGPPercentage = 100; // Default to 100%
    
    try {
      // Filter seasons - exclude the current season
      const pastSeasons = data.player_stats.filter(season => season.SEASON_ID !== "2024-25");
      
      // Get team's total games played from the comprehensive data
      const teamAbbr = latestSeason.TEAM_ABBREVIATION;
      let teamTotalGames = data.team_data?.total_games_played || 82;
      
      if (pastSeasons.length === 0) {
        // For new players, use only the current season's GP / team's total games
        const currentSeasonGP = latestSeason.GP || 0;
        careerGPPercentage = (currentSeasonGP / teamTotalGames) * 100;
      } else {
        // Calculate total games played in ALL seasons (including current)
        const allSeasonsGamesPlayed = data.player_stats.reduce((sum, season) => sum + season.GP, 0);
        
        // Calculate career GP percentage using team's total games as denominator
        careerGPPercentage = (allSeasonsGamesPlayed / (pastSeasons.length * 82 + teamTotalGames)) * 100;
      }
      
      // Apply Career GP% as a multiplier
      bpv = bpv * (careerGPPercentage / 100);
      
    } catch (error) {
      console.error('Error calculating Career GP%:', error);
    }
    
    // Check for players with 0 BPV after all adjustments
    if (playersWith0BPV.includes(playerName)) {
      bpv = 0;
    }
    
    // Cache the result for future use
    playerStatsCache[playerName] = bpv;
    
    return { bpv, cached: false };

  } catch (error) {
    console.error(`Error fetching comprehensive data for ${playerName}:`, error);
    return { bpv: 0, cached: false };
  }
}

// Update the calculateBPV function to use the provided last5Games data
async function calculateBPV(seasonStats, playerName, last5Games = null) {
  try {
    const { PTS, REB, AST, BLK, STL, TOV, FGA, FGM, FTA, FTM, FG3M, GP, TEAM_ABBREVIATION } = seasonStats;
    
    // Original BPV calculation for season stats
    const rawSeasonBPV = (PTS + REB + AST * 2 + BLK * 4 + STL * 4 - TOV * 2 + FGM * 2 - FGA + FTM - FTA + FG3M) / GP;
    
    // If no player name is provided or player is in the 0 BPV list, return early
    if (!playerName) {
      return rawSeasonBPV;
    }
    
    if (playersWith0BPV.includes(playerName)) {
      return 0;
    }
    
    // If no last 5 games data is provided, return the raw season BPV
    if (!last5Games || !Array.isArray(last5Games) || last5Games.length === 0) {
      return rawSeasonBPV;
    }
    
    // Initialize stats for last 5 games
    const lastGamesStats = {
      PTS: 0, REB: 0, AST: 0, BLK: 0, STL: 0, TOV: 0, 
      FGA: 0, FGM: 0, FTA: 0, FTM: 0, FG3M: 0
    };
    
    // Sum up stats from last 5 games
    last5Games.forEach(game => {
      lastGamesStats.PTS += parseFloat(game.PTS || 0);
      lastGamesStats.REB += parseFloat(game.REB || 0);
      lastGamesStats.AST += parseFloat(game.AST || 0);
      lastGamesStats.BLK += parseFloat(game.BLK || 0);
      lastGamesStats.STL += parseFloat(game.STL || 0);
      lastGamesStats.TOV += parseFloat(game.TOV || 0);
      lastGamesStats.FGA += parseFloat(game.FGA || 0);
      lastGamesStats.FGM += parseFloat(game.FGM || 0);
      lastGamesStats.FTA += parseFloat(game.FTA || 0);
      lastGamesStats.FTM += parseFloat(game.FTM || 0);
      lastGamesStats.FG3M += parseFloat(game.FG3M || 0);
    });
    
    // Calculate average stats for last 5 games
    const gamesCount = last5Games.length;
    Object.keys(lastGamesStats).forEach(stat => {
      lastGamesStats[stat] = lastGamesStats[stat] / gamesCount;
    });
    
    // Calculate BPV for last 5 games
    const last5GamesBPV = (
      lastGamesStats.PTS + lastGamesStats.REB + lastGamesStats.AST * 2 + 
      lastGamesStats.BLK * 4 + lastGamesStats.STL * 4 - lastGamesStats.TOV * 2 + 
      lastGamesStats.FGM * 2 - lastGamesStats.FGA + lastGamesStats.FTM - 
      lastGamesStats.FTA + lastGamesStats.FG3M
    );
    
    // Combine season BPV (80%) with last 5 games BPV (20%)
    // Note: In the original code it wasn't actually doing the weighting,
    // but here we'll implement it as the comment suggests
    const totalBPV = (rawSeasonBPV * 0.8) + (last5GamesBPV * 0.2);
        
    return totalBPV;
  } catch (error) {
    console.error(`Unexpected error in BPV calculation for ${playerName}:`, error);
    return 0; // Fallback to 0 in case of any unexpected errors
  }
}

    async function calculateBPV(seasonStats, playerName, last5Games = null, comprehensiveData = null) {
  try {
    const { PTS, REB, AST, BLK, STL, TOV, FGA, FGM, FTA, FTM, FG3M, GP, TEAM_ABBREVIATION } = seasonStats;
    
    // Original BPV calculation for season stats
    const rawSeasonBPV = (PTS + REB + AST * 2 + BLK * 4 + STL * 4 - TOV * 2 + FGM * 2 - FGA + FTM - FTA + FG3M) / GP;
    
    // If no player name is provided, return rawSeasonBPV
    if (!playerName) {
      return rawSeasonBPV;
    }

    // Hardcoded list of players with 0 BPV
    const playersWith0BPV = [
      "Larry Nance Jr", "Jalen Johnson", "Kobe Bufkin", "Noah Clowney", "Cam Thomas", 
      "Ayo Dosunmu", "Dante Exum", "Olivier-Maxence Prosper", "Kyrie Irving", 
      "Daron Holmes II", "Jaden Ivey", "Isaiah Jackson", "Brandon Clarke", 
      "Dru Smith", "CJ McCollum", "Trey Murphy III", "Herbert Jones", "Dejounte Murray", 
      "Ariel Hukporti", "Nikola Topic", "Jalen Suggs", "Moritz Wagner", "Tyrese Maxey", 
      "Joel Embiid", "Paul George", "Eric Gordon", "Jared McCain", "Bryce McGowens", 
      "Robert Williams III", "Victor Wembanyama", "De'Aaron Fox", "Riley Minix", 
      "Gradey Dick", "Ulrich Chomche", "Cody Williams", "Jordan Clarkson", 
      "Elijah Harkless", "Taylor Hendricks", "Corey Kispert", "Bilal Coulibaly"
    ];
    
    if (playersWith0BPV.includes(playerName)) {
      return 0;
    }
    
    // Get team abbreviation if available in season stats
    const teamAbbr = TEAM_ABBREVIATION || null;
    let teamGameDates = [];
    
    // If comprehensive data is provided, try to get team game dates from it
    if (comprehensiveData && comprehensiveData.team_data && comprehensiveData.team_data.last_5_games) {
      teamGameDates = comprehensiveData.team_data.last_5_games.map(game => game.GAME_DATE);
    }
    
    // If no team game dates yet, fetch from the comprehensive data endpoint
    if (teamGameDates.length === 0 && teamAbbr) {
      try {
        const response = await fetch(`http://127.0.0.1:5000/api/player_comprehensive_data?player_name=${encodeURIComponent(playerName)}`);
        const data = await response.json();
        
        if (data.team_data && data.team_data.last_5_games) {
          teamGameDates = data.team_data.last_5_games.map(game => game.GAME_DATE);
        }
      } catch (error) {
        console.error(`Error fetching team game dates for ${playerName}:`, error);
      }
    }
    
    // If last 5 games data is provided, use it directly
    let playerGames = last5Games;
    
    // If no last 5 games data is provided, make the API call
    if (!playerGames) {
      try {
        const response = await fetch(`http://127.0.0.1:5000/api/last_5_games?player_name=${encodeURIComponent(playerName)}`);
        if (!response.ok) {
          return rawSeasonBPV; // Return rawSeasonBPV if fetch fails
        }
        
        playerGames = await response.json();
        
        // If no last 5 games data or empty array, return rawSeasonBPV
        if (!playerGames || !Array.isArray(playerGames) || playerGames.length === 0) {
          return rawSeasonBPV;
        }
      } catch (error) {
        return rawSeasonBPV; // Return rawSeasonBPV if there's an error
      }
    }
    
    // Make sure playerGames is an array before filtering
    if (!Array.isArray(playerGames)) {
      return rawSeasonBPV;
    }
    
    // Filter player games to only include those that match team game dates
    let filteredGames = playerGames;
    
    if (teamGameDates && teamGameDates.length > 0) {
      try {
        // Updated filtering logic to handle different date string formats
        filteredGames = playerGames.filter(game => 
          teamGameDates.some(teamDate => {
            const formattedTeamDate = teamDate.trim().toUpperCase();
            const formattedGameDate = game.GAME_DATE.trim().toUpperCase();
            
            // Check for exact match or partial match
            return formattedTeamDate === formattedGameDate || 
                   formattedGameDate.includes(formattedTeamDate) || 
                   formattedTeamDate.includes(formattedGameDate);
          })
        );
        
        // If no games match, fall back to using rawSeasonBPV
        if (filteredGames.length === 0) {
          return rawSeasonBPV;
        }
      } catch (error) {
        console.error('Error filtering games:', error);
        return rawSeasonBPV; // Return rawSeasonBPV if there's an error filtering
      }
    }
    
    // Initialize stats for filtered games
    const filteredGameStats = {
      PTS: 0, REB: 0, AST: 0, BLK: 0, STL: 0, TOV: 0, 
      FGA: 0, FGM: 0, FTA: 0, FTM: 0, FG3M: 0
    };
    
    // Sum up stats from filtered games
    filteredGames.forEach(game => {
      filteredGameStats.PTS += parseFloat(game.PTS || 0);
      filteredGameStats.REB += parseFloat(game.REB || 0);
      filteredGameStats.AST += parseFloat(game.AST || 0);
      filteredGameStats.BLK += parseFloat(game.BLK || 0);
      filteredGameStats.STL += parseFloat(game.STL || 0);
      filteredGameStats.TOV += parseFloat(game.TOV || 0);
      filteredGameStats.FGA += parseFloat(game.FGA || 0);
      filteredGameStats.FGM += parseFloat(game.FGM || 0);
      filteredGameStats.FTA += parseFloat(game.FTA || 0);
      filteredGameStats.FTM += parseFloat(game.FTM || 0);
      filteredGameStats.FG3M += parseFloat(game.FG3M || 0);
    });
    
    // Calculate average stats for filtered games
    const gamesCount = filteredGames.length;
    Object.keys(filteredGameStats).forEach(stat => {
      filteredGameStats[stat] = filteredGameStats[stat] / gamesCount;
    });
    
    // Calculate BPV for filtered games
    const filteredGamesBPV = (
      filteredGameStats.PTS + filteredGameStats.REB + filteredGameStats.AST * 2 + 
      filteredGameStats.BLK * 4 + filteredGameStats.STL * 4 - filteredGameStats.TOV * 2 + 
      filteredGameStats.FGM * 2 - filteredGameStats.FGA + filteredGameStats.FTM - 
      filteredGameStats.FTA + filteredGameStats.FG3M
    );
    
    // Combine season BPV (80%) with filtered games BPV (20%)
    const totalBPV = rawSeasonBPV
        
    return totalBPV;
  } catch (error) {
    console.error(`Unexpected error in BPV calculation for ${playerName}:`, error);
    return 0; // Fallback to 0 in case of any unexpected errors
  }
}
 
    // Normalize player name by removing accents
    function normalizeString(str) {
      return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
    }

    document.getElementById("player-search").addEventListener("input", function () {
      const query = normalizeString(this.value);
      const suggestions = activePlayers.filter(player => normalizeString(player.name).includes(query));

      const suggestionList = document.getElementById('autocomplete-container');
      suggestionList.innerHTML = '';

      suggestions.slice(0, 6).forEach(player => {
        const div = document.createElement('div');
        div.textContent = player.name;
        div.addEventListener('click', () => {
          addPlayerToTeam(player, 1);
          suggestionList.innerHTML = ''; // Clear suggestions
          document.getElementById("player-search").value = ''; // Clear search bar
          document.getElementById("player-search").blur();
        });
        suggestionList.appendChild(div);
      });

      if (suggestions.length === 1 && query.length > 2) {
        addPlayerToTeam(suggestions[0], 1);
        suggestionList.innerHTML = ''; // Clear suggestions
        document.getElementById("player-search").value = ''; // Clear search bar
        document.getElementById("player-search").blur();
      }

      if (query === '') {
        suggestionList.innerHTML = ''; // Clear suggestions when input is empty
      }
    });

    document.getElementById("player-search-2").addEventListener("input", function () {
      const query = normalizeString(this.value);
      const suggestions = activePlayers.filter(player => normalizeString(player.name).includes(query));

      const suggestionList = document.getElementById('autocomplete-container-2');
      suggestionList.innerHTML = '';

      suggestions.slice(0, 6).forEach(player => {
        const div = document.createElement('div');
        div.textContent = player.name;
        div.addEventListener('click', () => {
          addPlayerToTeam(player, 2);
          suggestionList.innerHTML = ''; // Clear suggestions
          document.getElementById("player-search-2").value = ''; // Clear search bar
          document.getElementById("player-search-2").blur();
        });
        suggestionList.appendChild(div);
      });

      if (suggestions.length === 1 && query.length > 2) {
        addPlayerToTeam(suggestions[0], 2);
        suggestionList.innerHTML = ''; // Clear suggestions
        document.getElementById("player-search-2").value = ''; // Clear search bar
        document.getElementById("player-search-2").blur();
      }

      if (query === '') {
        suggestionList.innerHTML = ''; // Clear suggestions when input is empty
      }
    });

    // Add event listener for Enter key in search boxes
    document.getElementById("player-search").addEventListener("keypress", function(event) {
      if (event.key === "Enter" && this.value.trim() !== '') {
        const query = normalizeString(this.value);
        const suggestions = activePlayers.filter(player => normalizeString(player.name).includes(query));
        
        if (suggestions.length === 1) {
          addPlayerToTeam(suggestions[0], 1);
          document.getElementById('autocomplete-container').innerHTML = '';
          this.value = '';
          this.blur();
        } else if (suggestions.length > 0) {
          // If multiple matches, add the first one that starts with the query
          const exactMatches = suggestions.filter(player => 
            normalizeString(player.name).startsWith(query));
          
          if (exactMatches.length > 0) {
            addPlayerToTeam(exactMatches[0], 1);
            document.getElementById('autocomplete-container').innerHTML = '';
            this.value = '';
            this.blur();
          }
        }
      }
    });

    document.getElementById("player-search-2").addEventListener("keypress", function(event) {
      if (event.key === "Enter" && this.value.trim() !== '') {
        const query = normalizeString(this.value);
        const suggestions = activePlayers.filter(player => normalizeString(player.name).includes(query));
        
        if (suggestions.length === 1) {
          addPlayerToTeam(suggestions[0], 2);
          document.getElementById('autocomplete-container-2').innerHTML = '';
          this.value = '';
          this.blur();
        } else if (suggestions.length > 0) {
          // If multiple matches, add the first one that starts with the query
          const exactMatches = suggestions.filter(player => 
            normalizeString(player.name).startsWith(query));
          
          if (exactMatches.length > 0) {
            addPlayerToTeam(exactMatches[0], 2);
            document.getElementById('autocomplete-container-2').innerHTML = '';
            this.value = '';
            this.blur();
          }
        }
      }
    });

    function addPlayerToTeam(player, teamId) {
      const players = teamId === 1 ? team1Players : team2Players;
      
      // Add a small visual feedback when adding player
      const teamElement = teamId === 1 ? 
        document.querySelector('.team:first-child') : 
        document.querySelector('.team:last-child');
      
      teamElement.style.transition = 'transform 0.2s ease, box-shadow 0.2s ease';
      teamElement.style.transform = 'scale(1.01)';
      teamElement.style.boxShadow = 'var(--shadow-lg), 0 0 10px rgba(52, 152, 219, 0.5)';
      
      setTimeout(() => {
        teamElement.style.transform = '';
        teamElement.style.boxShadow = '';
      }, 300);
      
      // Check if player is already in the other team
      const otherTeamPlayers = teamId === 1 ? team2Players : team1Players;
      if (otherTeamPlayers.includes(player.name)) {
        const otherTeam = teamId === 1 ? 2 : 1;
        removePlayerFromTeam(player.name, otherTeam);
      }
      
      // Check if player is already in this team
      if (!players.includes(player.name)) {
        if (teamId === 1) {
          team1Players.push(player.name);
        } else {
          team2Players.push(player.name);
        }
        
        updateWatchlist(teamId);
        
        // Prefetch player stats for faster analysis
        fetchPlayerStats(player.name);
      }
    }

    function removePlayerFromTeam(player, teamId) {
      if (teamId === 1) {
        team1Players = team1Players.filter(p => p !== player);
        updateWatchlist(1);
      } else if (teamId === 2) {
        team2Players = team2Players.filter(p => p !== player);
        updateWatchlist(2);
      }
    }

    function updateWatchlist(teamId) {
      const watchlist = teamId === 1 ? document.getElementById("watchlist") : document.getElementById("watchlist-2");
      const players = teamId === 1 ? team1Players : team2Players;
      
      // Clear the watchlist
      watchlist.innerHTML = '';
      
      // Create HTML for a table with 4 rows and 2 columns
      let tableHTML = '<table class="players-table">';
      
      // Create 4 rows
      for (let row = 0; row < 4; row++) {
        tableHTML += '<tr>';
        
        // Left column (players 0-3)
        tableHTML += '<td style="width:50%; padding:0;">';
        if (row < players.length) {
          tableHTML += `<div class="player-item" onclick="removePlayerFromTeam('${players[row]}', ${teamId})">${players[row]}</div>`;
        }
        tableHTML += '</td>';
        
        // Right column (players 4-7)
        tableHTML += '<td style="width:50%; padding:0;">';
        if (row + 4 < players.length) {
          tableHTML += `<div class="player-item" onclick="removePlayerFromTeam('${players[row + 4]}', ${teamId})">${players[row + 4]}</div>`;
        }
        tableHTML += '</td>';
        
        tableHTML += '</tr>';
      }
      
      tableHTML += '</table>';
      
      // Set the HTML directly
      watchlist.innerHTML = tableHTML;
    }
    
    // Make removePlayerFromTeam accessible globally for the HTML string onclick
    window.removePlayerFromTeam = removePlayerFromTeam;

    document.getElementById("analyze-btn").addEventListener("click", async function () {
  const analyzeButton = document.getElementById("analyze-btn");
  const resultDiv = document.getElementById("trade-result");
  const startTime = performance.now();
  
  // Remove any existing ripple elements first
  const existingRipple = analyzeButton.querySelector('.ripple');
  if (existingRipple) {
    existingRipple.remove();
  }
  
  // Add a ripple effect to the button
  const ripple = document.createElement('span');
  ripple.classList.add('ripple');
  ripple.style.position = 'absolute';
  ripple.style.top = '0';
  ripple.style.left = '0';
  ripple.style.width = '100%';
  ripple.style.height = '100%';
  ripple.style.background = 'rgba(255, 255, 255, 0.4)';
  ripple.style.borderRadius = 'inherit';
  ripple.style.transform = 'scale(0)';
  ripple.style.opacity = '1';
  ripple.style.animation = 'ripple 0.6s linear';
  ripple.style.pointerEvents = 'none';
  
  analyzeButton.appendChild(ripple);
  
  // Use setTimeout to ensure the ripple animation completes
  const rippleTimeout = setTimeout(() => {
    if (ripple && ripple.parentNode === analyzeButton) {
      analyzeButton.removeChild(ripple);
    }
  }, 600);
  
  analyzeButton.innerHTML = "<span>Analyzing... <span class='loading-spinner'></span></span>";
  analyzeButton.disabled = true;
  resultDiv.innerHTML = "<div style='text-align: center;'>Calculating trade values...<div class='loading-spinner' style='margin: 20px auto; display: block;'></div></div>";
  resultDiv.classList.add('active');

      let totalBPV1 = 0;
      let totalBPV2 = 0;
      let team1Details = [];
      let team2Details = [];

      // Calculate total BPV for Team 1
      for (const player of team1Players) {
        const result = await fetchPlayerStats(player);
        totalBPV1 += result.bpv;
        team1Details.push({
          name: player,
          bpv: result.bpv,
          cached: result.cached
        });
      }

      // Calculate total BPV for Team 2
      for (const player of team2Players) {
        const result = await fetchPlayerStats(player);
        totalBPV2 += result.bpv;
        team2Details.push({
          name: player,
          bpv: result.bpv,
          cached: result.cached
        });
      }

      const endTime = performance.now();
      const analysisTime = (endTime - startTime).toFixed(2);
      
      if (debugMode) {
        document.getElementById('performance-stats').innerHTML = `Analysis took ${analysisTime}ms`;
      }

      if (team1Players.length === 0 || team2Players.length === 0) {
        resultDiv.innerHTML = "<div class='result-title'>Please add players to both teams to analyze the trade.</div>";
      } else {
        const bpvDifference = Math.abs(totalBPV1 - totalBPV2);
        let resultHTML = '';
        
        // Determine which team is getting better value
        const team1Value = totalBPV1.toFixed(2);
        const team2Value = totalBPV2.toFixed(2);
        const valueDifference = Math.abs(totalBPV1 - totalBPV2).toFixed(2);
        const percentDifference = totalBPV1 > totalBPV2 ? 
          Math.round((totalBPV1 / totalBPV2 - 1) * 100) : 
          Math.round((totalBPV2 / totalBPV1 - 1) * 100);
        
        let resultTitle = '';
        
        if (Math.abs(totalBPV1 - totalBPV2) < 0.01) {
          resultTitle = `<div class='result-title'><span style='color: var(--secondary-color);'>This trade is perfectly even!</span> (Â±0.00 BPV)</div>`;
        } else if (totalBPV1 < totalBPV2) {
          resultTitle = `<div class='result-title'>
            <span class='win-indicator'>You're winning</span> this trade by 
            <span style='font-weight: bold;'>${valueDifference} BPV</span>
          </div>`;
        } else {
          resultTitle = `<div class='result-title'>
            <span class='lose-indicator'>You're losing</span> this trade by 
            <span style='font-weight: bold;'>${valueDifference} BPV</span>
          </div>`;
        }
        
        resultHTML = resultTitle;
        
        // Add detailed breakdown of player values
        resultHTML += "<div class='teams-comparison'>";
        
        // Team 1 details
        resultHTML += "<div class='team-column'>";
        resultHTML += "<h3 style='color: var(--primary-color);'>Team 1 (Giving)</h3>";
        team1Details.forEach(player => {
          resultHTML += `<div class='player-row'>
            <span class='player-name'>${player.name}${player.cached ? '<span class="cache-indicator">cached</span>' : ''}</span>
            <span class='player-value'>${player.bpv.toFixed(2)}</span>
          </div>`;
        });
        resultHTML += `<div class='team-total'>
          <span>Total:</span>
          <span style='color: var(--secondary-color);'>${totalBPV1.toFixed(2)} BPV</span>
        </div>`;
        resultHTML += "</div>";
        
        // Team 2 details
        resultHTML += "<div class='team-column'>";
        resultHTML += "<h3 style='color: var(--accent-color);'>Team 2 (Receiving)</h3>";
        team2Details.forEach(player => {
          resultHTML += `<div class='player-row'>
            <span class='player-name'>${player.name}${player.cached ? '<span class="cache-indicator">cached</span>' : ''}</span>
            <span class='player-value'>${player.bpv.toFixed(2)}</span>
          </div>`;
        });
        resultHTML += `<div class='team-total'>
          <span>Total:</span>
          <span style='color: var(--secondary-color);'>${totalBPV2.toFixed(2)} BPV</span>
        </div>`;
        resultHTML += "</div>";
        
        resultHTML += "</div>";
        
        resultDiv.innerHTML = resultHTML;
      }

      setTimeout(() => {
  const resultDiv = document.getElementById("trade-result");
  if (resultDiv) {
    resultDiv.scrollIntoView({ 
      behavior: 'smooth', 
      block: 'center' // This centers the result in the viewport
    });
  }
}, 300);

      analyzeButton.innerHTML = "<span>Analyze Trade</span>";
      analyzeButton.disabled = false;
    });

    // Add keyframe animation for ripple effect
const styleSheet = document.createElement('style');
styleSheet.textContent = `
  @keyframes ripple {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }
  .analyze-btn {
    position: relative;
    overflow: hidden;
  }
`;
document.head.appendChild(styleSheet);

    // Add fade-in animation when the page loads
    document.addEventListener('DOMContentLoaded', function() {
      document.body.style.opacity = 0;
      setTimeout(() => {
        document.body.style.transition = 'opacity 0.8s ease';
        document.body.style.opacity = 1;
      }, 100);
    });
  </script>
</body>
</html>